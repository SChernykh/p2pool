diff --git a/crypto/rand/windows.cc b/crypto/rand/windows.cc
index ebd0d4afd..65e877f0e 100644
--- a/crypto/rand/windows.cc
+++ b/crypto/rand/windows.cc
@@ -24,6 +24,7 @@
 #include <stdlib.h>
 
 #include <windows.h>
+#include <wincrypt.h>
 
 using namespace bssl;
 
@@ -59,16 +60,39 @@ void bssl::CRYPTO_sysrand(uint8_t *out, size_t requested) {
 // See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
 typedef BOOL(WINAPI *ProcessPrngFunction)(PBYTE pbData, SIZE_T cbData);
 static ProcessPrngFunction g_processprng_fn = nullptr;
+static HCRYPTPROV g_hCryptProv = 0;
+
+static BOOL WINAPI wrapper_CryptGenRandom(PBYTE pbData, SIZE_T cbData)
+{
+  return CryptGenRandom(g_hCryptProv, cbData, pbData);
+}
 
 static void init_processprng() {
   HMODULE hmod = LoadLibraryW(L"bcryptprimitives");
-  if (hmod == nullptr) {
-    abort();
+  if (hmod) {
+    g_processprng_fn = (ProcessPrngFunction)GetProcAddress(hmod, "ProcessPrng");
+    if (g_processprng_fn) {
+      return;
+    }
   }
-  g_processprng_fn = (ProcessPrngFunction)GetProcAddress(hmod, "ProcessPrng");
-  if (g_processprng_fn == nullptr) {
-    abort();
+
+  if (CryptAcquireContext(&g_hCryptProv, NULL, NULL, PROV_RSA_FULL, 0)) {
+    g_processprng_fn = &wrapper_CryptGenRandom;
+    return;
   }
+
+  DWORD err = GetLastError();
+  if (err == NTE_BAD_KEYSET) {
+    if (CryptAcquireContext(&g_hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET)) {
+      g_processprng_fn = &wrapper_CryptGenRandom;
+      return;
+    }
+    else {
+      err = GetLastError();
+    }
+  }
+
+  abort();
 }
 
 void bssl::CRYPTO_init_sysrand() {
